---
import { Icon } from '../../utils';
import type { StudioCMSColorway } from '../../utils/colors';
import { generateID } from '../../utils/generateID';
import type { HeroIconName } from '../../utils/iconType';

interface Tab {
  icon?: HeroIconName;
  label: string;
  color: Exclude<StudioCMSColorway, 'default'>;
  tabId: string;
}

/**
 * The props for the Tabs component.
 */
interface Props {
  /**
   * The sync key for the tabs. If provided, the active tab will be synced across all instances of the tabs with the same sync key.
   * Ad
   */
  syncKey?: string;
  storage?: 'session' | 'persistent';
  variant?: 'default' | 'starlight';
  align?: 'left' | 'center' | 'right';
}

const extractTabInfoWithRegex = (input: string) => {
  const tabItemRegex = /<sui-tab-item([^>]*)>/g;

  const attributeRegex = /data-([\w-]+)="([^"]*)"/g;

  const tabs: Tab[] = [];
  let tabMatch: RegExpExecArray | null;

  // biome-ignore lint/suspicious/noAssignInExpressions: Nop
  while ((tabMatch = tabItemRegex.exec(input)) !== null) {
    let attributes: { [key: string]: string } = {};

    let attributeMatch: RegExpExecArray | null;

    if (!tabMatch[1]) continue;

    // biome-ignore lint/suspicious/noAssignInExpressions: Nop
    while ((attributeMatch = attributeRegex.exec(tabMatch[1])) !== null) {
      if (!attributeMatch[1] || !attributeMatch[2]) continue;

      if (
        attributeMatch[1] === 'icon' || 
        attributeMatch[1] === 'label' || 
        attributeMatch[1] === 'color'
      ) {
        attributes[attributeMatch[1]] = attributeMatch[2];
      }

      if (attributeMatch[1] === 'tab-id') {
        attributes.tabId = attributeMatch[2];
      }
    }

    tabs.push(attributes as unknown as Tab);
  }

  return tabs;
};

const markTabAsActive = (tabId: string, html: string): string => {
  if (!tabId) return html;

  const updatedHtml = html.replace(
    new RegExp(`(<sui-tab-item[^>]*data-tab-id="${tabId}"[^>]*class=")([^"]*)(")`, 'g'),
    '$1$2 active$3'
  );

  return updatedHtml;
}

const { 
  syncKey: originalSyncKey, 
  storage = 'session', 
  variant = 'default',
  align = 'left'
} = Astro.props;

const syncKey = originalSyncKey ? `sui-tabs-${originalSyncKey}` : undefined;

const tabContents = await Astro.slots.render('default');
const tabs = extractTabInfoWithRegex(tabContents);
const finalizedTabContents = markTabAsActive(tabs[0]?.tabId || "", tabContents);
const containerId = generateID('sui-tabs-container');
---

<div class="sui-tabs-container" id={containerId} data-sync-key={syncKey} class:list={[variant, align]}>
  <div class="sui-tabs-list">
    {tabs.map((tab, i) => (
      <button 
        role="tab"
        class="sui-tab-header"
        class:list={[i === 0 && "active", tab.color, syncKey && `${syncKey}:${i}`]}
        data-tab-child={tab.tabId}
        id={syncKey ? `${syncKey}-${i}` : undefined}
      >
        {tab.icon && (
          <Icon name={tab.icon} width={24} height={24} />
        )}
        <span>{tab.label}</span>
      </button>
    ))}
  </div>
  <div class="sui-tabs-content">
    <Fragment set:html={finalizedTabContents} />
  </div>
</div>
<script is:inline define:vars={{ syncKey, containerId, storage }}>
  let storageLayer = storage === 'session' ? sessionStorage : localStorage;

  const constructCustomEvent = (tabIndex) => {
    return new CustomEvent(`sui-tab-switch:${syncKey}`, {
      detail: {
        tabIndex
      }
    });
  }

  const switchTab = (e, container) => {
    const activeChildren = container.querySelectorAll('.active');
    
    for (const child of activeChildren) {
      child.classList.remove('active');
    }

    const newActiveTab = e.target;
    newActiveTab.classList.add('active');

    const newActiveTabContentId = newActiveTab.dataset.tabChild;
    const newActiveTabContent = container.querySelector(`sui-tab-item[data-tab-id="${newActiveTabContentId}"]`);

    newActiveTabContent.classList.add('active');

    if (syncKey) {
      const tabIndex = Array.prototype.indexOf.call(newActiveTab.parentElement.children, newActiveTab);
      storageLayer.setItem(syncKey, tabIndex);

      document.dispatchEvent(constructCustomEvent(tabIndex));
    }
  }

  const initTabs = () => {
    const container = document.getElementById(containerId);

    if (container.dataset.active) return;

    container.dataset.active = "true";

    const tabHeaders = container.querySelectorAll('.sui-tab-header');

    for (const tab of tabHeaders) {
      tab.addEventListener('click', (e) => switchTab(e, container));
    }

    if (syncKey) {
      // Retrieve the sync key value from localstorage, set the tab.
      const activeTabIndex = storageLayer.getItem(syncKey);

      if (activeTabIndex) {
        console.log(container.querySelector);
        const activeTab = container.querySelector(`#${syncKey}-${activeTabIndex}`);
        activeTab.click();
      }

      document.addEventListener(`sui-tab-switch:${syncKey}`, (e) => {
        const { tabIndex } = e.detail;

        const activeTab = container.querySelector(`#${syncKey}-${tabIndex}`);
        activeTab.click();
      });
    }
  }

  document.addEventListener('DOMContentLoaded', initTabs);
</script>
<style>
  .sui-tabs-container {
    width: 100%;
  }

  .sui-tabs-list {
    display: flex;
    flex-direction: row;
    gap: 1rem;
    align-items: center;
    width: 100%;
    overflow-x: auto;
    overflow-y: hidden;
    margin-bottom: 2rem;
    position: relative;
  }

  .center .sui-tabs-list {
    justify-content: center;
  }

  .right .sui-tabs-list {
    justify-content: flex-end;
  }

  .sui-tab-header {
    margin-top: 0 !important;
    display: flex;
    flex-direction: row;
    gap: .5rem;
    cursor: pointer;
    position: relative;
    min-width: fit-content;
  }

  .default .sui-tab-header {
    border-radius: 0.5rem;
    height: 40px;
    padding: 0.5rem 0.75rem;
    transition: all .15s ease;
    font-size: 0.875em;
  }

  .sui-tab-header * {
    pointer-events: none;
  }

  .default .sui-tab-header:hover {
    background-color: hsla(var(--default-flat-active)) !important;
  }

  .default .sui-tab-header.active {
    background-color: hsla(var(--primary-flat-active)) !important;
  }

  .default .sui-tab-header.success.active {
    background-color: hsla(var(--success-flat-active)) !important;
  }

  .default .sui-tab-header.warning.active {
    background-color: hsla(var(--warning-flat-active)) !important;
  }

  .default .sui-tab-header.danger.active {
    background-color: hsla(var(--danger-flat-active)) !important;
  }

  .starlight .sui-tabs-list {
    margin-bottom: 1rem;
  }

  .starlight .sui-tabs-list::before {
    content: "";
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    height: 2px;
    background-color: hsl(var(--border));
  }

  .starlight .sui-tab-header {
    border-radius: 0.5rem;
    padding: 0.25rem 1.25rem;
    color: hsl(var(--text-muted));
  }

  .starlight .sui-tab-header.active {
    font-weight: 600;
    color: hsl(var(--text));
  }

  .starlight .sui-tab-header.active::after {
    content: "";
    width: 100%;
    height: 2px;
    background-color: hsl(var(--primary-base));
    position: absolute;
    bottom: 0;
    left: 0;
    z-index: 15;
  }

  .default .sui-tab-header.active {
    background-color: hsla(var(--primary-flat-active)) !important;
  }

  .sui-tabs-content {
    width: 100%;
    margin: 0 !important;
  }
</style>
